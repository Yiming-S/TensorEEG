

# ==============================================================================
# TensorEEG Validation: Spatial & Temporal Covariance Analysis
# ==============================================================================
#
# Description:
#   This script serves as a critical validation document for the TensorEEG library. 
#   Its purpose is to mathematically verify that the synthetic data generated by 
#   the engine adheres to the physical and physiological constraints of real EEG.
#
# Theoretical Validation Targets:
#   1. Spatial Domain (Volume Conduction & Rank Deficiency):
#      - Real EEG is not full rank; 64 channels are driven by fewer latent sources.
#      - We verify this "Low-Rank" property using Singular Value Decomposition (SVD) 
#        on the spatial covariance matrix.
#      - We also verify "Volume Conduction" by checking for block-diagonal structures 
#        in the spatial covariance, ensuring neighboring sensors are highly correlated.
#
#   2. Temporal Domain (Oscillatory Dynamics):
#      - The VAR(2) background process must generate stable oscillations, not white noise.
#      - We verify this by inspecting the Temporal Covariance Matrix for "checkerboard" 
#        patterns (indicative of rhythmicity).
#      - We use the Autocorrelation Function (ACF) to precisely confirm the presence 
#        of the target frequencies (e.g., 10Hz Alpha, 20Hz Beta).
#
# Usage:
#   Execute this script to audit the output of `sim_eeg_master`. Successful validation 
#   confirms the tensor is ready for use in tensor decomposition or Riemannian 
#   geometry benchmarking.
# ==============================================================================

# 1. Run standard simulation
set.seed(42)
fixed_freqs <- c(10, 12, 10, 10, 20, 20, 22, 20, 10, 20) 
sim_result <- sim_eeg_master(n_trials = 10, 
                             n_time = 500, 
                             n_channels = 64,
                             target_freqs = fixed_freqs,
                             drift_power_ratio = 0.5)

# Data Prep: Extract first trial and apply 1Hz High-Pass Filter (HPF).
# This removes low-frequency drift which would otherwise mask the fine covariance structure.
X_raw <- sim_result$data[,,1] # [Time x Channel]
fs <- sim_result$params$fs
bf_hp <- signal::butter(4, 1/(fs/2), type="high")
X_neural <- apply(X_raw, 2, function(x) signal::filtfilt(bf_hp, x))

# ==============================================================================
# Module A: Spatial Covariance Validation
# Objective: Verify Volume Conduction effects and Low-Rank properties.
# ==============================================================================

# Compute Spatial Covariance Matrix S (64 x 64)
# Formula: S = Cov(X)
S_cov <- cov(X_neural)

# Compute Eigenvalues via SVD to verify effective rank
eigen_S <- eigen(S_cov, only.values = TRUE)$values
eigen_S
# Normalize eigenvalues to observe energy distribution
eigen_norm <- eigen_S / sum(eigen_S)
eigen_norm

# ==============================================================================
# Module B: Temporal Covariance Validation
# Objective: Verify Oscillatory dynamics and Stationarity.
# ==============================================================================

# Compute Temporal Covariance Matrix T (Time x Time)
# Subset first 200 points (0.8s) for clearer visualization.
t_subset <- 1:200
X_sub <- X_neural[t_subset, ]

# Center the data
X_sub <- sweep(X_sub, 2, colMeans(X_sub), "-")
# Formula: T = (X * X^T) / N_channels (Averaged over spatial dimension)
T_cov <- (X_sub %*% t(X_sub)) / ncol(X_sub)
T_cov

# Compute Average Autocorrelation Function (ACF)
# Objective: Check for expected 10Hz/20Hz periodicity.
acf_avg <- rowMeans(apply(X_neural, 2, function(x) {
  acf(x, lag.max = 100, plot = FALSE)$acf
}))
lags_ms <- (0:100) / fs * 1000
lags_ms

# ==============================================================================
# Visualization Dashboard
# ==============================================================================
par(mfrow = c(2, 2), mar = c(4, 4, 3, 2))

# Plot 1: Spatial Covariance Heatmap
image(S_cov[, ncol(S_cov):1], main = "Spatial Covariance (64x64)",
      axes = FALSE, col = hcl.colors(20, "YlOrRd", rev = TRUE))
mtext("Sensor i", side=2, line=1); mtext("Sensor j", side=1, line=1)
box()
# Interpretation: Block-like structure (off-diagonal correlations) indicates 
# strong coupling between neighboring sensors (Volume Conduction).

# Plot 2: Spatial Eigenvalues (Scree Plot)
plot(eigen_norm[1:20], type = 'b', pch = 19, col = "blue", lwd = 2,
     main = "Spatial Eigenvalues (Rank Test)",
     xlab = "Component Index", ylab = "Explained Variance Ratio")
# Mark true source number (10)
abline(v = 10, col = "red", lty = 2)
text(10, max(eigen_norm)*0.8, "True Sources = 10", col = "red", pos = 4)
# Interpretation: Eigenvalues should drop sharply after index 10, entering the noise plateau.

# Plot 3: Temporal Covariance Heatmap
image(T_cov[, ncol(T_cov):1], main = "Temporal Covariance (0-0.8s)",
      axes = FALSE, col = hcl.colors(20, "Viridis"))
mtext("Time t1", side=2, line=1); mtext("Time t2", side=1, line=1)
box()
# Interpretation: Checkerboard pattern parallel to the diagonal indicates 
# periodic oscillatory structure.

# Plot 4: Temporal Autocorrelation (ACF)
plot(lags_ms, acf_avg, type = 'l', lwd = 2, col = "darkgreen",
     main = "Avg Autocorrelation (ACF)",
     xlab = "Lag (ms)", ylab = "Correlation")
abline(h = 0, col = "gray", lty = 2)
# Mark 20Hz (50ms) and 10Hz (100ms) periods
abline(v = c(50, 100), col = "red", lty = 3)
text(50, 0.5, "20Hz", col="red", pos=3, cex=0.8)
text(100, 0.5, "10Hz", col="red", pos=3, cex=0.8)
# Interpretation: Distinct side-lobe peaks should appear at 50ms (20Hz) and 100ms (10Hz).

par(mfrow = c(1, 1))